<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>CubeThree.ts</title>
    <script src="https://unpkg.com/three@0.85.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    
    <canvas id="c"></canvas>

</body>

</html>

<!-- // add styles
import './style.css';
// three.js
import * as THREE from 'three';
import { Geometry, Mesh, LineBasicMaterial } from 'three';


var
  OBJLoader: any,
  OrbitControls: new (arg0: any, arg1: any) => any,
  scene: THREE.Scene,
  renderer: THREE.WebGLRenderer,
  controls: { update: () => void; },
  camera: THREE.PerspectiveCamera,
  raycaster: THREE.Raycaster = new THREE.Raycaster(),
  mouse: THREE.Vector2 = new THREE.Vector2(),
  cubes: Cube[] = new Array;

function initScene(camX: number, camY: number, camZ: number): void {
  scene = new THREE.Scene();
  scene.background = new THREE.Color("white");
  let canvas: HTMLCanvasElement = document.querySelector('#c');

  renderer = new THREE.WebGLRenderer({ canvas });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);


  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.x = camX;
  camera.position.y = camY;
  camera.position.z = camZ;

  OBJLoader = require('three-obj-loader')(THREE)
  OrbitControls = require('three-orbit-controls')(THREE)
  controls = new OrbitControls(camera, renderer.domElement);
  scene.add(new THREE.AxesHelper(1000));

  raycaster = new THREE.Raycaster(),
    mouse = new THREE.Vector2();
  renderer.domElement.addEventListener('click', raycast, false);
}


class Sphere {
  /**
   * Номер вершины, к которому принадлежит сфера
   */
  vertice: number;
  color: String;
  id: number; // id в сцене three.js для поиска после трассировки

  body: THREE.Mesh;
}


class Edge {

  v:number;

  line : THREE.Line;
}


class Cube {

  edges: Edge[] = new Array;  // массив ребер куба

  spheres: Sphere[] = new Array;

  cube_vertices: THREE.Vector3[] = [
    new THREE.Vector3(0, 0, 0), // 0
    new THREE.Vector3(0, 0, -1), // 1
    new THREE.Vector3(1, 0, -1), // 2
    new THREE.Vector3(1, 0, 0), // 3
    new THREE.Vector3(1, 1, 0), // 4
    new THREE.Vector3(0, 1, 0), // 5
    new THREE.Vector3(0, 1, -1), // 6
    new THREE.Vector3(1, 1, -1), // 7
  ];

  constructor(xOffset: number, yOffset: number, zOffset: number, size : number) {
    this.cube_vertices.forEach((v) => {
      v.x = (v.x + xOffset)*size;
      v.y = (v.y + yOffset)*size;
      v.z = (v.z + zOffset)*size;
    });
  }
}



// Список смежности вершин куба
const CUBE_EDGES = [
  [1, 3, 5],
  [0, 2, 6],
  [1, 3, 7],
  [0, 2, 4],
  [3, 5, 7],
  [0, 4, 6],
  [1, 5, 7],
  [2, 4, 6]
];

function randomColor(brightness) {
  function randomChannel(brightness) {
    var r = 255 - brightness;
    var n = 0 | ((Math.random() * r) + brightness);
    var s = n.toString(16);
    return (s.length == 1) ? '0' + s : s;
  }
  return '#' + randomChannel(brightness) + randomChannel(brightness) + randomChannel(brightness);
}


function createCube(xOffset: number, yOffset: number, zOffset: number, size : number): Cube {

  var cube: Cube = new Cube(xOffset, yOffset, zOffset, size);

  for (var i = 0; i < CUBE_EDGES.length; i++) {

    for (let j = 0; j < CUBE_EDGES[i].length; j++) {
      let material = new THREE.LineBasicMaterial({ color: "black" });
      let lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(cube.cube_vertices[i]);
      lineGeometry.vertices.push(cube.cube_vertices[CUBE_EDGES[i][j]]);

      let edge = new Edge();
      edge.line = new THREE.Line(lineGeometry, material);
      edge.v = i;
      cube.edges.push(edge);
    }


    let sphereMaterial = new THREE.MeshBasicMaterial({ color: randomColor(1) })
    let sphereGeometry = new THREE.SphereGeometry(size / 10, 32, 32);
    let sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.x = cube.cube_vertices[i].x;
    sphere.position.y = cube.cube_vertices[i].y;
    sphere.position.z = cube.cube_vertices[i].z;

    let sphereObject = new Sphere;
    sphereObject.body = sphere;
    sphereObject.vertice = i;
    sphereObject.id = sphere.id;
    cube.spheres.push(sphereObject);
  }

  cube.edges.forEach((v, ind) => {
    scene.add(v.line);
  });

  cube.spheres.forEach((sph, ind) => {
    scene.add(sph.body);
  });


  return cube;
}


function animate() {
  requestAnimationFrame(animate);
  render();
}


function render() {
  controls.update();
  renderer.render(scene, camera);
}

function raycast(e) {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = 1 - (e.clientY / window.innerHeight) * 2;

  raycaster.setFromCamera(mouse, camera);

  var intersects = raycaster.intersectObjects(scene.children);

  for (var i = 0; i < intersects.length; i++) {
    if (intersects[i].face) {
      console.log(intersects[i].object);
      let color:string = intersects[i].object.material.color;
      paintEdges(intersects[i].object.id, color);
    }
  }
}


function paintEdges(id: number, color:string):void {
  cubes.forEach((cube, ind) => {
    cube.spheres.forEach((sph, ind) => {
      if(sph.id == id) {
        for(let i = 0; i < cubes[0].edges.length; i++) {
          if(cube.edges[i].v == sph.vertice) {

              cube.edges[i].line.material = new LineBasicMaterial({color : color, linewidth : 5});
            
          }
        }
      }
    });
  });
}


function rand(min:number, max:number):number {
  return Math.random() * (max - min) + min; 
}

function randomCubes() {
  let n = parseInt(prompt("Введите N"));
  let min = -10;
  let max = 5;
  for(let i = 0; i < n; i++) {
    cubes.push(createCube(rand(min, max), rand(min, max), rand(min, max), rand(0, max)));
  } 
}


function main() {

  initScene(0, 0, -10);
  randomCubes();
  animate();
}

main();

 -->